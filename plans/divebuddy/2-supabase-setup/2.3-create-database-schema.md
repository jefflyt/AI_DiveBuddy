# Step 2.3: Create Database Schema

**Part of:** PR 1.2 - Supabase Setup  
**Focus:** Design and implement PostgreSQL database schema for DiveBuddy  
**Estimated Time:** 25 minutes

## Overview

Create the database tables for knowledge base content, user sessions, chat messages, and supporting structures. This schema supports RAG (Retrieval-Augmented Generation) with pgvector for semantic search.

## Pre-Step Checklist

- [ ] **Completed:** Step 2.2 - Supabase client installed
- [ ] **Access:** Supabase Dashboard SQL Editor available
- [ ] **Verified:** Supabase project is active

## Implementation

### Goal

Build production-ready database schema with proper constraints, indexes, and Row Level Security (RLS).

### Step-by-Step Instructions

#### Step 1: Create Core Tables

Open Supabase Dashboard → SQL Editor → New Query, paste and run:

```sql
-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- 1. Knowledge Base Documents
CREATE TABLE documents (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  title TEXT NOT NULL,
  content TEXT NOT NULL,
  category TEXT NOT NULL CHECK (category IN ('education', 'destination', 'general')),
  subcategory TEXT,
  metadata JSONB DEFAULT '{}'::jsonb,
  source_url TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 2. Document Chunks (for RAG)
CREATE TABLE document_chunks (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
  content TEXT NOT NULL,
  chunk_index INTEGER NOT NULL,
  embedding VECTOR(768),  -- text-embedding-004 dimension
  metadata JSONB DEFAULT '{}'::jsonb,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(document_id, chunk_index)
);

-- 3. User Sessions
CREATE TABLE sessions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  context JSONB DEFAULT '{}'::jsonb,
  intent TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  last_activity_at TIMESTAMPTZ DEFAULT NOW()
);

-- 4. Chat Messages
CREATE TABLE messages (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  session_id UUID NOT NULL REFERENCES sessions(id) ON DELETE CASCADE,
  role TEXT NOT NULL CHECK (role IN ('user', 'agent', 'system')),
  content TEXT NOT NULL,
  metadata JSONB DEFAULT '{}'::jsonb,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 5. Destinations (for trip planning)
CREATE TABLE destinations (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  country TEXT NOT NULL DEFAULT 'Malaysia',
  region TEXT,
  description TEXT,
  dive_sites JSONB DEFAULT '[]'::jsonb,
  best_season TEXT,
  difficulty_level TEXT CHECK (difficulty_level IN ('beginner', 'intermediate', 'advanced')),
  features JSONB DEFAULT '[]'::jsonb,
  coordinates JSONB,
  image_url TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 6. User Profiles (extended auth.users)
CREATE TABLE profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  full_name TEXT,
  certification_level TEXT CHECK (certification_level IN ('none', 'OW', 'AOW', 'rescue', 'divemaster', 'instructor')),
  total_dives INTEGER DEFAULT 0,
  preferences JSONB DEFAULT '{}'::jsonb,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 7. Interaction Logs (for analytics)
CREATE TABLE interaction_logs (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  session_id UUID REFERENCES sessions(id) ON DELETE SET NULL,
  user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
  intent TEXT,
  agent_used TEXT,
  response_time_ms INTEGER,
  success BOOLEAN DEFAULT TRUE,
  error_message TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

#### Step 2: Create Indexes

```sql
-- Performance indexes
CREATE INDEX idx_documents_category ON documents(category);
CREATE INDEX idx_documents_created_at ON documents(created_at DESC);

CREATE INDEX idx_chunks_document_id ON document_chunks(document_id);
CREATE INDEX idx_chunks_chunk_index ON document_chunks(chunk_index);

CREATE INDEX idx_sessions_user_id ON sessions(user_id);
CREATE INDEX idx_sessions_last_activity ON sessions(last_activity_at DESC);

CREATE INDEX idx_messages_session_id ON messages(session_id);
CREATE INDEX idx_messages_created_at ON messages(created_at);

CREATE INDEX idx_destinations_country ON destinations(country);
CREATE INDEX idx_destinations_difficulty ON destinations(difficulty_level);

CREATE INDEX idx_logs_session_id ON interaction_logs(session_id);
CREATE INDEX idx_logs_created_at ON interaction_logs(created_at DESC);
```

#### Step 3: Add Updated Timestamp Triggers

```sql
-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Apply to tables with updated_at
CREATE TRIGGER update_documents_updated_at
  BEFORE UPDATE ON documents
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_sessions_updated_at
  BEFORE UPDATE ON sessions
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_destinations_updated_at
  BEFORE UPDATE ON destinations
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_profiles_updated_at
  BEFORE UPDATE ON profiles
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();
```

#### Step 4: Create Vector Search Function

```sql
-- Function for semantic search (used by RAG)
CREATE OR REPLACE FUNCTION match_documents(
  query_embedding VECTOR(768),
  match_threshold FLOAT DEFAULT 0.7,
  match_count INT DEFAULT 5,
  filter_category TEXT DEFAULT NULL
)
RETURNS TABLE (
  id UUID,
  document_id UUID,
  content TEXT,
  similarity FLOAT,
  metadata JSONB
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT
    dc.id,
    dc.document_id,
    dc.content,
    1 - (dc.embedding <=> query_embedding) AS similarity,
    dc.metadata
  FROM document_chunks dc
  LEFT JOIN documents d ON dc.document_id = d.id
  WHERE 
    (filter_category IS NULL OR d.category = filter_category)
    AND (1 - (dc.embedding <=> query_embedding)) > match_threshold
  ORDER BY dc.embedding <=> query_embedding
  LIMIT match_count;
END;
$$;
```

#### Step 5: Set Up Row Level Security (RLS)

```sql
-- Enable RLS on all tables
ALTER TABLE documents ENABLE ROW LEVEL SECURITY;
ALTER TABLE document_chunks ENABLE ROW LEVEL SECURITY;
ALTER TABLE sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE destinations ENABLE ROW LEVEL SECURITY;
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE interaction_logs ENABLE ROW LEVEL SECURITY;

-- Public read access for knowledge base
CREATE POLICY "Documents are publicly readable"
  ON documents FOR SELECT
  USING (true);

CREATE POLICY "Document chunks are publicly readable"
  ON document_chunks FOR SELECT
  USING (true);

CREATE POLICY "Destinations are publicly readable"
  ON destinations FOR SELECT
  USING (true);

-- Users can only access their own sessions
CREATE POLICY "Users can view own sessions"
  ON sessions FOR SELECT
  USING (auth.uid() = user_id OR user_id IS NULL);

CREATE POLICY "Users can create sessions"
  ON sessions FOR INSERT
  WITH CHECK (auth.uid() = user_id OR user_id IS NULL);

CREATE POLICY "Users can update own sessions"
  ON sessions FOR UPDATE
  USING (auth.uid() = user_id OR user_id IS NULL);

-- Users can only access their own messages
CREATE POLICY "Users can view own messages"
  ON messages FOR SELECT
  USING (
    session_id IN (
      SELECT id FROM sessions WHERE user_id = auth.uid() OR user_id IS NULL
    )
  );

CREATE POLICY "Users can create messages"
  ON messages FOR INSERT
  WITH CHECK (
    session_id IN (
      SELECT id FROM sessions WHERE user_id = auth.uid() OR user_id IS NULL
    )
  );

-- Users can only access their own profile
CREATE POLICY "Users can view own profile"
  ON profiles FOR SELECT
  USING (auth.uid() = id);

CREATE POLICY "Users can update own profile"
  ON profiles FOR UPDATE
  USING (auth.uid() = id);

-- Interaction logs are admin-only
CREATE POLICY "Only service role can access logs"
  ON interaction_logs FOR ALL
  USING (auth.jwt() ->> 'role' = 'service_role');
```

#### Step 6: Create Profile Trigger

```sql
-- Auto-create profile when user signs up
CREATE OR REPLACE FUNCTION create_profile_for_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO profiles (id, full_name)
  VALUES (NEW.id, NEW.raw_user_meta_data->>'full_name');
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW
  EXECUTE FUNCTION create_profile_for_user();
```

#### Step 7: Seed Sample Data (Optional)

```sql
-- Insert sample destinations
INSERT INTO destinations (name, country, region, description, difficulty_level, best_season) VALUES
('Sipadan Island', 'Malaysia', 'Sabah', 'World-class diving with barracudas, turtles, and hammerhead sharks.', 'advanced', 'March-October'),
('Perhentian Islands', 'Malaysia', 'Terengganu', 'Crystal-clear waters perfect for beginner divers. Coral gardens and reef sharks.', 'beginner', 'March-October'),
('Tioman Island', 'Malaysia', 'Pahang', 'Diverse marine life including nudibranchs, seahorses, and occasional whale sharks.', 'intermediate', 'March-October'),
('Redang Island', 'Malaysia', 'Terengganu', 'Shallow reefs ideal for Open Water divers. Turtle sanctuary.', 'beginner', 'March-October'),
('Mabul Island', 'Malaysia', 'Sabah', 'Macro photography paradise with frogfish, blue-ringed octopus, and flamboyant cuttlefish.', 'intermediate', 'March-October');

-- Insert sample education content
INSERT INTO documents (title, content, category, subcategory) VALUES
('Buoyancy Control Fundamentals', 'Buoyancy control is the foundation of good diving. It allows you to hover effortlessly, conserve air, protect the reef, and dive safely...', 'education', 'OW'),
('Deep Diving Safety', 'Deep diving (18-30m for AOW) requires special considerations: nitrogen narcosis awareness, air consumption planning, buddy communication...', 'education', 'AOW'),
('Underwater Navigation Basics', 'Natural navigation uses reef features, light direction, and wave patterns. Compass navigation uses headings and reciprocal courses...', 'education', 'AOW');
```

## Verification Checklist

- [ ] All 7 tables created successfully
- [ ] Indexes created on key columns
- [ ] `updated_at` triggers working
- [ ] `match_documents` function created
- [ ] RLS policies enabled and tested
- [ ] Profile auto-creation trigger working
- [ ] Sample data inserted (optional)

## Testing

Test the schema in Supabase SQL Editor:

```sql
-- Verify tables exist
SELECT table_name 
FROM information_schema.tables 
WHERE table_schema = 'public' 
ORDER BY table_name;

-- Test vector search function (requires pgvector)
SELECT * FROM match_documents(
  ARRAY[0.1, 0.2, ...]::VECTOR(768),  -- dummy embedding
  0.5,
  3,
  'education'
);

-- Check RLS policies
SELECT schemaname, tablename, policyname 
FROM pg_policies 
WHERE schemaname = 'public';
```

## Troubleshooting

| Issue | Solution |
|-------|----------|
| `uuid-ossp` extension error | Enable in Supabase Dashboard → Database → Extensions |
| `VECTOR` type not found | Complete Step 2.4 (enable pgvector) first |
| RLS policy errors | Check auth.users() is available (Supabase built-in) |
| Trigger not firing | Verify function and trigger creation had no errors |
| Cannot insert into `profiles` | Check auth.users exists and trigger is created |

## Files Created

- ✅ Database schema executed via Supabase SQL Editor
- ✅ 7 tables: documents, document_chunks, sessions, messages, destinations, profiles, interaction_logs
- ✅ Indexes for performance
- ✅ RLS policies for security
- ✅ Vector search function for RAG
- ✅ Triggers for auto-updates

## What Comes Next

**Step 2.4:** Enable pgvector extension for semantic search

This schema provides the foundation for:

- RAG-powered knowledge retrieval
- Multi-turn conversation history
- Trip planning recommendations
- User profile management
- Analytics and monitoring
