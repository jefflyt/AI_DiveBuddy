# Step 2.4: Enable pgvector Extension

**Part of:** PR 1.2 - Supabase Setup  
**Focus:** Enable PostgreSQL vector similarity search for RAG  
**Estimated Time:** 5 minutes

## Overview

Enable the `pgvector` extension in Supabase to support semantic search with vector embeddings. This is critical for the RAG (Retrieval-Augmented Generation) pipeline.

## Pre-Step Checklist

- [ ] **Completed:** Step 2.3 - Database schema created
- [ ] **Access:** Supabase Dashboard Database settings
- [ ] **Verified:** `document_chunks` table exists with `embedding VECTOR(768)` column

## Implementation

### Goal

Activate pgvector extension and create vector similarity index for fast semantic search.

### Step-by-Step Instructions

#### Step 1: Enable pgvector Extension

**Option A: Via Supabase Dashboard (Recommended)**

1. Go to Supabase Dashboard → **Database** → **Extensions**
2. Search for `pgvector` in the search bar
3. Toggle the switch to **enable** pgvector
4. Wait for confirmation (usually instant)

**Option B: Via SQL Editor**

Open SQL Editor → New Query:

```sql
-- Enable pgvector extension
CREATE EXTENSION IF NOT EXISTS vector;

-- Verify installation
SELECT extname, extversion 
FROM pg_extension 
WHERE extname = 'vector';
```

#### Step 2: Create Vector Index

Add ivfflat index for fast similarity search:

```sql
-- Create index on embeddings
-- Using cosine distance (inner product for normalized vectors)
CREATE INDEX ON document_chunks 
USING ivfflat (embedding vector_cosine_ops)
WITH (lists = 100);

-- Alternative: L2 distance (Euclidean)
-- CREATE INDEX ON document_chunks 
-- USING ivfflat (embedding vector_l2_ops)
-- WITH (lists = 100);
```

**Index Parameters:**
- `lists = 100`: Number of clusters (good for ~100k vectors)
- For smaller datasets (<10k vectors), use `lists = 10-50`
- For larger datasets (>1M vectors), increase to `lists = 1000`

#### Step 3: Test Vector Operations

```sql
-- Test: Create a sample embedding
INSERT INTO documents (title, content, category) 
VALUES ('Test Document', 'This is a test for vector search.', 'general')
RETURNING id;

-- Insert test chunk with embedding (replace {doc_id} with actual ID)
INSERT INTO document_chunks (document_id, content, chunk_index, embedding)
VALUES (
  '{doc_id}',  -- Use the ID from above
  'This is a test for vector search.',
  0,
  ARRAY[0.1, 0.2, 0.3, ..., 0.5]::VECTOR(768)  -- 768-dim vector
);

-- Test similarity search
SELECT 
  content,
  1 - (embedding <=> ARRAY[0.1, 0.2, ...]::VECTOR(768)) AS similarity
FROM document_chunks
ORDER BY embedding <=> ARRAY[0.1, 0.2, ...]::VECTOR(768)
LIMIT 5;
```

#### Step 4: Verify match_documents Function

Test the RAG search function created in Step 2.3:

```sql
-- Create a dummy query embedding (normally from Gemini API)
SELECT * FROM match_documents(
  ARRAY[0.1, 0.2, 0.3, ..., 0.5]::VECTOR(768),  -- query embedding
  0.5,           -- similarity threshold (0.0-1.0)
  5,             -- max results
  'education'    -- filter by category
);
```

Expected output:
```
id | document_id | content | similarity | metadata
---+-------------+---------+------------+----------
...matching chunks with similarity scores...
```

#### Step 5: Create Utility Functions

Add helper functions for vector operations:

```sql
-- Function: Get embedding dimension
CREATE OR REPLACE FUNCTION get_embedding_dimension()
RETURNS INTEGER AS $$
BEGIN
  RETURN 768;  -- text-embedding-004
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- Function: Count total vectors
CREATE OR REPLACE FUNCTION count_vectors()
RETURNS BIGINT AS $$
BEGIN
  RETURN (SELECT COUNT(*) FROM document_chunks WHERE embedding IS NOT NULL);
END;
$$ LANGUAGE plpgsql;

-- Function: Find similar documents (wrapper)
CREATE OR REPLACE FUNCTION search_similar(
  query_text TEXT,
  query_embedding VECTOR(768),
  top_k INTEGER DEFAULT 5
)
RETURNS TABLE (
  document_title TEXT,
  chunk_content TEXT,
  similarity FLOAT
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    d.title,
    dc.content,
    1 - (dc.embedding <=> query_embedding) AS similarity
  FROM document_chunks dc
  JOIN documents d ON dc.document_id = d.id
  WHERE dc.embedding IS NOT NULL
  ORDER BY dc.embedding <=> query_embedding
  LIMIT top_k;
END;
$$ LANGUAGE plpgsql;
```

#### Step 6: Add Vector Validation

Create constraints to ensure data quality:

```sql
-- Add check: Ensure embeddings are non-null for indexed chunks
ALTER TABLE document_chunks
ADD CONSTRAINT embedding_not_null_when_active
CHECK (embedding IS NOT NULL OR chunk_index < 0);

-- Add function to validate embedding dimensions
CREATE OR REPLACE FUNCTION validate_embedding_dimension()
RETURNS TRIGGER AS $$
BEGIN
  IF array_length(NEW.embedding::REAL[], 1) != 768 THEN
    RAISE EXCEPTION 'Embedding must have exactly 768 dimensions';
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger to validate on insert/update
CREATE TRIGGER check_embedding_dimension
  BEFORE INSERT OR UPDATE ON document_chunks
  FOR EACH ROW
  WHEN (NEW.embedding IS NOT NULL)
  EXECUTE FUNCTION validate_embedding_dimension();
```

## Verification Checklist

- [ ] pgvector extension enabled
- [ ] Vector index created on `document_chunks.embedding`
- [ ] Test embeddings inserted and queried successfully
- [ ] `match_documents` function returns results
- [ ] Utility functions created
- [ ] Dimension validation trigger working

## Testing

Run comprehensive tests:

```sql
-- 1. Check extension is enabled
SELECT * FROM pg_extension WHERE extname = 'vector';

-- 2. Check index exists
SELECT indexname, indexdef
FROM pg_indexes
WHERE tablename = 'document_chunks' AND indexdef LIKE '%ivfflat%';

-- 3. Test vector operations
SELECT 
  ARRAY[1,2,3]::VECTOR(3) <=> ARRAY[1,2,3]::VECTOR(3) AS same_vector_distance,
  ARRAY[1,2,3]::VECTOR(3) <=> ARRAY[4,5,6]::VECTOR(3) AS different_vector_distance;

-- 4. Verify utility functions
SELECT get_embedding_dimension();
SELECT count_vectors();

-- 5. Test search_similar function
SELECT * FROM search_similar(
  'buoyancy control',
  ARRAY[0.1, ...]::VECTOR(768),
  3
);
```

Expected results:
- Extension version: `0.5.0` or higher
- Index type: `ivfflat`
- Distance values: same=0, different>0

## Troubleshooting

| Issue | Solution |
|-------|----------|
| `extension "vector" does not exist` | Enable via Dashboard → Extensions → pgvector |
| `type "vector" does not exist` | Restart Supabase connection or SQL editor |
| Index creation fails | Ensure table has at least 1 row with non-null embedding |
| Dimension mismatch error | Check embedding is exactly 768-dimensional |
| Slow search queries | Increase `lists` parameter or add more training data |

## Performance Tuning

### For Production

```sql
-- Increase index lists for larger datasets
DROP INDEX IF EXISTS document_chunks_embedding_idx;
CREATE INDEX document_chunks_embedding_idx ON document_chunks 
USING ivfflat (embedding vector_cosine_ops)
WITH (lists = 500);  -- Adjust based on dataset size

-- Add partial index for specific categories
CREATE INDEX document_chunks_education_embedding_idx ON document_chunks 
USING ivfflat (embedding vector_cosine_ops)
WITH (lists = 50)
WHERE document_id IN (SELECT id FROM documents WHERE category = 'education');
```

### Query Optimization

```sql
-- Use prepared statements for better performance
PREPARE search_query (VECTOR(768), FLOAT, INT) AS
SELECT * FROM match_documents($1, $2, $3);

EXECUTE search_query(
  ARRAY[0.1, ...]::VECTOR(768),
  0.7,
  5
);
```

## Distance Metrics

pgvector supports three distance operators:

| Operator | Distance Type | Use Case |
|----------|---------------|----------|
| `<=>` | Cosine distance | **Recommended** for normalized embeddings |
| `<->` | L2 (Euclidean) | Magnitude-sensitive search |
| `<#>` | Inner product | For non-normalized vectors |

**DiveBuddy uses:** `<=>` (cosine) because Google's `text-embedding-004` produces normalized vectors.

## Files Created

- ✅ pgvector extension enabled in Supabase
- ✅ ivfflat index on `document_chunks.embedding`
- ✅ Utility functions: `get_embedding_dimension`, `count_vectors`, `search_similar`
- ✅ Validation trigger for embedding dimensions

## What Comes Next

**PR 1.2 Complete!** ✅

Supabase is now fully configured with:
- Database schema for knowledge base and sessions
- Vector search capability for RAG
- Row Level Security for multi-user access

**Next Step:** PR 1.3 - Implement Authentication

Or jump to Phase 2 PR 2.2 to start creating embeddings!
