# Step 2.3.5: Create Orchestrator Agent

**Part of:** PR 2.3 - Google AI Agent Framework Integration  
**Focus:** Build orchestrator agent with intent routing and session coordination  
**Estimated Time:** 25 minutes

## Overview

Create the orchestrator agent that serves as the entry point for all user messages. It classifies intent, maintains session state, delegates to specialist agents, and coordinates the overall conversation flow.

## Pre-Step Checklist

- [ ] **Completed:** Step 2.3.4 - Specialist agents created
- [ ] **Tools:** Intent classifier and vector search tools available
- [ ] **Session:** SessionManager implemented

## Implementation

### Goal

Build an orchestrator that intelligently routes conversations to the right specialist agent while maintaining session continuity.

### Step-by-Step Instructions

#### Step 1: Create Orchestrator Agent

Create `src/lib/agents/orchestrator.ts`:

```typescript
import { sessionManager } from './session-manager'
import { ContextManager } from './context-manager'
import { AgentFactory } from './agent-factory'
import { ResponseFormatter } from './response-formatter'
import { intentClassifierTool } from './tools/intent-classifier'
import type { Session, Intent } from './types'

export class OrchestratorAgent {
  /**
   * Main entry point for handling user messages
   */
  async handleMessage(params: {
    message: string
    sessionId?: string
    userId?: string
  }): Promise<{
    response: string
    sessionId: string
    intent: Intent
    agentUsed: string
  }> {
    try {
      // Step 1: Get or create session
      const session = await sessionManager.getOrCreate(params.sessionId, params.userId)
      
      // Step 2: Add user message to session
      await sessionManager.addMessage(session.id, 'user', params.message)
      
      // Step 3: Classify intent
      const conversationHistory = session.messages
        .slice(-5) // Last 5 messages for context
        .map(m => `${m.role}: ${m.content}`)
      
      const intentResult = await intentClassifierTool.execute({
        message: params.message,
        conversationHistory,
      })
      
      const intent = intentResult.success ? intentResult.intent : 'general'
      
      // Step 4: Get appropriate specialist agent
      const agent = AgentFactory.getAgent(intent)
      const agentName = AgentFactory.getAgentName(intent)
      
      console.log(`[Orchestrator] Routing to ${agentName} for intent: ${intent}`)
      
      // Step 5: Get agent response
      const agentResponse = await agent.handleMessage(params.message, session)
      
      // Step 6: Add agent response to session
      await sessionManager.addMessage(session.id, 'agent', agentResponse, {
        intent,
        agent: agentName,
      })
      
      // Step 7: Update session context
      const updatedContext = ContextManager.updateContextFromMessage(
        session.context,
        params.message,
        agentResponse
      )
      await sessionManager.updateContext(session.id, updatedContext)
      
      // Step 8: Return formatted response
      return {
        response: agentResponse,
        sessionId: session.id,
        intent,
        agentUsed: agentName,
      }
    } catch (error) {
      console.error('[Orchestrator] Error handling message:', error)
      
      // Fallback response
      return {
        response: "I'm having trouble processing your request right now. Please try again in a moment.",
        sessionId: params.sessionId || 'error',
        intent: 'general',
        agentUsed: 'Error Handler',
      }
    }
  }
  
  /**
   * Get session history for display
   */
  async getSessionHistory(sessionId: string) {
    const session = await sessionManager.getOrCreate(sessionId)
    return {
      sessionId: session.id,
      messages: session.messages.map(m => ({
        role: m.role,
        content: m.content,
        timestamp: m.timestamp,
        metadata: m.metadata,
      })),
      context: session.context,
    }
  }
  
  /**
   * Clear session and start fresh
   */
  async resetSession(sessionId: string) {
    await sessionManager.deleteSession(sessionId)
    return { success: true, message: 'Session reset successfully' }
  }
  
  /**
   * Get user's all sessions
   */
  async getUserSessions(userId: string) {
    const sessions = await sessionManager.getUserSessions(userId)
    return sessions.map(s => ({
      id: s.id,
      lastMessage: s.messages[s.messages.length - 1]?.content || 'New conversation',
      messageCount: s.messages.length,
      updatedAt: s.updatedAt,
    }))
  }
}

// Export singleton instance
export const orchestrator = new OrchestratorAgent()
```

#### Step 2: Create Streaming Response Handler

Create `src/lib/agents/streaming-handler.ts`:

```typescript
import { getChatModel } from '@/lib/ai/gemini'
import type { Session } from './types'

export class StreamingHandler {
  /**
   * Stream agent response for real-time UI updates
   */
  static async *streamResponse(
    prompt: string,
    session: Session
  ): AsyncGenerator<string, void, unknown> {
    try {
      const model = getChatModel(0.4)
      
      // Get conversation history for context
      const history = session.messages.slice(-10).map(m => ({
        role: m.role === 'agent' ? 'model' : 'user',
        parts: [m.content],
      }))
      
      // Create chat session
      const chat = model.startChat({
        history,
      })
      
      // Stream the response
      const result = await chat.sendMessageStream(prompt)
      
      for await (const chunk of result.stream) {
        const text = chunk.text()
        if (text) {
          yield text
        }
      }
    } catch (error) {
      console.error('Streaming error:', error)
      yield "I'm having trouble generating a response. Please try again."
    }
  }
  
  /**
   * Convert async generator to ReadableStream for API routes
   */
  static toReadableStream(generator: AsyncGenerator<string, void, unknown>): ReadableStream {
    return new ReadableStream({
      async start(controller) {
        try {
          for await (const chunk of generator) {
            controller.enqueue(new TextEncoder().encode(chunk))
          }
          controller.close()
        } catch (error) {
          controller.error(error)
        }
      },
    })
  }
}
```

#### Step 3: Create Agent Middleware

Create `src/lib/agents/middleware.ts`:

```typescript
import type { Intent } from './types'

export class AgentMiddleware {
  /**
   * Rate limiting per session
   */
  private static sessionRateLimits = new Map<string, number[]>()
  
  static checkRateLimit(sessionId: string, maxPerMinute = 10): boolean {
    const now = Date.now()
    const timestamps = this.sessionRateLimits.get(sessionId) || []
    
    // Remove timestamps older than 1 minute
    const recentTimestamps = timestamps.filter(ts => now - ts < 60000)
    
    if (recentTimestamps.length >= maxPerMinute) {
      return false
    }
    
    recentTimestamps.push(now)
    this.sessionRateLimits.set(sessionId, recentTimestamps)
    return true
  }
  
  /**
   * Content moderation (basic)
   */
  static moderateContent(message: string): {
    allowed: boolean
    reason?: string
  } {
    // Basic checks - extend as needed
    const prohibitedPatterns = [
      /\b(spam|scam|fraud)\b/i,
      /\b(illegal|drugs)\b/i,
    ]
    
    for (const pattern of prohibitedPatterns) {
      if (pattern.test(message)) {
        return {
          allowed: false,
          reason: 'Message contains prohibited content',
        }
      }
    }
    
    // Check message length
    if (message.length > 2000) {
      return {
        allowed: false,
        reason: 'Message too long (max 2000 characters)',
      }
    }
    
    if (message.length < 2) {
      return {
        allowed: false,
        reason: 'Message too short',
      }
    }
    
    return { allowed: true }
  }
  
  /**
   * Log agent interaction for monitoring
   */
  static logInteraction(params: {
    sessionId: string
    userId?: string
    intent: Intent
    agent: string
    responseTime: number
    success: boolean
  }) {
    // In production, send to analytics/monitoring service
    console.log('[Agent Metrics]', {
      timestamp: new Date().toISOString(),
      ...params,
    })
  }
}
```

#### Step 4: Create Agent Configuration

Create `src/lib/agents/config.ts`:

```typescript
export const AGENT_CONFIG = {
  // Model settings
  models: {
    education: {
      model: 'gemini-1.5-flash-latest',
      temperature: 0.3,
      maxOutputTokens: 1024,
    },
    tripPlanning: {
      model: 'gemini-1.5-flash-latest',
      temperature: 0.5,
      maxOutputTokens: 1536,
    },
    orchestrator: {
      model: 'gemini-1.5-flash-latest',
      temperature: 0.4,
      maxOutputTokens: 2048,
    },
  },
  
  // RAG settings
  rag: {
    education: {
      searchLimit: 3,
      threshold: 0.7,
      category: 'education' as const,
    },
    tripPlanning: {
      searchLimit: 5,
      threshold: 0.65,
      category: 'destinations' as const,
    },
  },
  
  // Session settings
  session: {
    historyLimit: 20, // Max messages to keep in context
    summaryAfter: 30, // Generate summary after N messages
    maxIdleMinutes: 60, // Consider session stale after N minutes
  },
  
  // Rate limiting
  rateLimit: {
    messagesPerMinute: 10,
    messagesPerHour: 100,
  },
  
  // Feature flags
  features: {
    streaming: true,
    suggestions: true,
    destinationCards: true,
    sessionPersistence: true,
  },
} as const
```

## Verification Checklist

- [ ] `src/lib/agents/orchestrator.ts` created with OrchestratorAgent class
- [ ] `src/lib/agents/streaming-handler.ts` created for streaming responses
- [ ] `src/lib/agents/middleware.ts` created with rate limiting and moderation
- [ ] `src/lib/agents/config.ts` created with agent configuration
- [ ] Orchestrator correctly routes to specialist agents
- [ ] Rate limiting works correctly
- [ ] No TypeScript errors

## Troubleshooting

| Issue | Solution |
|-------|----------|
| Intent classification incorrect | Review intentClassifierTool prompt, add more examples |
| Agent not receiving context | Check SessionManager.getOrCreate returns full session |
| Rate limit too strict | Adjust `maxPerMinute` in config |
| Streaming not working | Verify Vercel AI SDK installed and configured |

## Files Created

- ✅ Created: `src/lib/agents/orchestrator.ts` - Main orchestrator agent
- ✅ Created: `src/lib/agents/streaming-handler.ts` - Response streaming utilities
- ✅ Created: `src/lib/agents/middleware.ts` - Rate limiting and moderation
- ✅ Created: `src/lib/agents/config.ts` - Agent configuration

## What Comes Next

Next step: **2.3.6-integrate-chat-api.md** - Connect agents to Next.js API route
