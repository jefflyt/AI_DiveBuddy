# Step 2.3.3: Create Session Manager (MCP Pattern)

**Part of:** PR 2.3 - Google AI Agent Framework Integration  
**Focus:** Build session management with Model Context Protocol pattern  
**Estimated Time:** 25 minutes

## Overview

Implement session management following the MCP (Model Context Protocol) pattern to maintain conversation state, history, and context across multiple agent interactions. This enables persistent, context-aware conversations.

## Pre-Step Checklist

- [ ] **Completed:** Step 2.3.2 - Vector search tools created
- [ ] **Database:** Supabase `chat_sessions` and `messages` tables exist
- [ ] **Types:** Agent types defined in `src/lib/agents/types.ts`

## Implementation

### Goal

Create a session manager that stores conversation history, manages context, and provides MCP-compliant session access for agents.

### Step-by-Step Instructions

#### Step 1: Create Session Manager

Create `src/lib/agents/session-manager.ts`:

```typescript
import { createClient } from '@/lib/supabase/server'
import { v4 as uuidv4 } from 'uuid'
import type { Session, Message } from './types'

export class SessionManager {
  private supabase = createClient()

  /**
   * Get existing session or create new one
   * MCP Pattern: Session as context provider
   */
  async getOrCreate(sessionId?: string, userId?: string): Promise<Session> {
    // If no sessionId provided, create new session
    if (!sessionId) {
      return this.createSession(userId)
    }

    // Try to fetch existing session
    const { data: sessionData, error } = await this.supabase
      .from('chat_sessions')
      .select(`
        *,
        messages (
          id,
          role,
          content,
          metadata,
          created_at
        )
      `)
      .eq('id', sessionId)
      .single()

    if (error || !sessionData) {
      // Session not found, create new one
      return this.createSession(userId, sessionId)
    }

    // Return existing session with messages
    return {
      id: sessionData.id,
      userId: sessionData.user_id,
      messages: sessionData.messages.map((msg: any) => ({
        id: msg.id,
        sessionId: sessionData.id,
        role: msg.role,
        content: msg.content,
        metadata: msg.metadata || {},
        timestamp: new Date(msg.created_at),
      })),
      context: sessionData.context || {},
      createdAt: new Date(sessionData.created_at),
      updatedAt: new Date(sessionData.updated_at),
    }
  }

  /**
   * Create new session
   */
  private async createSession(userId?: string, sessionId?: string): Promise<Session> {
    const id = sessionId || uuidv4()

    const { data, error } = await this.supabase
      .from('chat_sessions')
      .insert({
        id,
        user_id: userId,
        context: {},
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      })
      .select()
      .single()

    if (error) {
      throw new Error(`Failed to create session: ${error.message}`)
    }

    return {
      id: data.id,
      userId: data.user_id,
      messages: [],
      context: {},
      createdAt: new Date(data.created_at),
      updatedAt: new Date(data.updated_at),
    }
  }

  /**
   * Add message to session
   * Persists to database for conversation history
   */
  async addMessage(
    sessionId: string,
    role: 'user' | 'agent' | 'system',
    content: string,
    metadata?: Record<string, any>
  ): Promise<Message> {
    const { data, error } = await this.supabase
      .from('messages')
      .insert({
        id: uuidv4(),
        session_id: sessionId,
        role,
        content,
        metadata: metadata || {},
        created_at: new Date().toISOString(),
      })
      .select()
      .single()

    if (error) {
      throw new Error(`Failed to add message: ${error.message}`)
    }

    // Update session timestamp
    await this.supabase
      .from('chat_sessions')
      .update({ updated_at: new Date().toISOString() })
      .eq('id', sessionId)

    return {
      id: data.id,
      sessionId: data.session_id,
      role: data.role,
      content: data.content,
      metadata: data.metadata,
      timestamp: new Date(data.created_at),
    }
  }

  /**
   * Update session context
   * MCP Pattern: Store agent state and context
   */
  async updateContext(sessionId: string, context: Record<string, any>): Promise<void> {
    const { error } = await this.supabase
      .from('chat_sessions')
      .update({
        context,
        updated_at: new Date().toISOString(),
      })
      .eq('id', sessionId)

    if (error) {
      throw new Error(`Failed to update context: ${error.message}`)
    }
  }

  /**
   * Get conversation history formatted for Gemini
   */
  async getConversationHistory(sessionId: string, limit = 20): Promise<Array<{role: string, parts: string[]}>> {
    const { data, error } = await this.supabase
      .from('messages')
      .select('role, content')
      .eq('session_id', sessionId)
      .order('created_at', { ascending: false })
      .limit(limit)

    if (error) {
      console.error('Failed to fetch conversation history:', error)
      return []
    }

    // Reverse to get chronological order
    return data.reverse().map(msg => ({
      role: msg.role === 'agent' ? 'model' : 'user',
      parts: [msg.content],
    }))
  }

  /**
   * Delete session and all messages
   */
  async deleteSession(sessionId: string): Promise<void> {
    // Messages will be cascade deleted due to foreign key constraint
    const { error } = await this.supabase
      .from('chat_sessions')
      .delete()
      .eq('id', sessionId)

    if (error) {
      throw new Error(`Failed to delete session: ${error.message}`)
    }
  }

  /**
   * Get user's recent sessions
   */
  async getUserSessions(userId: string, limit = 10): Promise<Session[]> {
    const { data, error } = await this.supabase
      .from('chat_sessions')
      .select(`
        *,
        messages (
          id,
          role,
          content,
          created_at
        )
      `)
      .eq('user_id', userId)
      .order('updated_at', { ascending: false })
      .limit(limit)

    if (error) {
      console.error('Failed to fetch user sessions:', error)
      return []
    }

    return data.map((session: any) => ({
      id: session.id,
      userId: session.user_id,
      messages: session.messages.map((msg: any) => ({
        id: msg.id,
        sessionId: session.id,
        role: msg.role,
        content: msg.content,
        metadata: {},
        timestamp: new Date(msg.created_at),
      })),
      context: session.context || {},
      createdAt: new Date(session.created_at),
      updatedAt: new Date(session.updated_at),
    }))
  }
}

// Export singleton instance
export const sessionManager = new SessionManager()
```

#### Step 2: Update Database Schema for Sessions

Create migration `supabase/migrations/005_session_management.sql`:

```sql
-- Ensure chat_sessions table exists
CREATE TABLE IF NOT EXISTS chat_sessions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  context JSONB DEFAULT '{}'::jsonb,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Ensure messages table exists
CREATE TABLE IF NOT EXISTS messages (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  session_id UUID REFERENCES chat_sessions(id) ON DELETE CASCADE NOT NULL,
  role TEXT NOT NULL CHECK (role IN ('user', 'agent', 'system')),
  content TEXT NOT NULL,
  metadata JSONB DEFAULT '{}'::jsonb,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create indexes for performance
CREATE INDEX IF NOT EXISTS idx_chat_sessions_user_id ON chat_sessions(user_id);
CREATE INDEX IF NOT EXISTS idx_chat_sessions_updated_at ON chat_sessions(updated_at DESC);
CREATE INDEX IF NOT EXISTS idx_messages_session_id ON messages(session_id);
CREATE INDEX IF NOT EXISTS idx_messages_created_at ON messages(created_at DESC);

-- Enable Row Level Security
ALTER TABLE chat_sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE messages ENABLE ROW LEVEL SECURITY;

-- RLS Policies for chat_sessions
CREATE POLICY "Users can view their own sessions"
  ON chat_sessions FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can create their own sessions"
  ON chat_sessions FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own sessions"
  ON chat_sessions FOR UPDATE
  USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own sessions"
  ON chat_sessions FOR DELETE
  USING (auth.uid() = user_id);

-- RLS Policies for messages
CREATE POLICY "Users can view messages from their sessions"
  ON messages FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM chat_sessions
      WHERE chat_sessions.id = messages.session_id
      AND chat_sessions.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can create messages in their sessions"
  ON messages FOR INSERT
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM chat_sessions
      WHERE chat_sessions.id = messages.session_id
      AND chat_sessions.user_id = auth.uid()
    )
  );
```

Run migration:

```bash
# In Supabase SQL Editor, paste and run the migration
# Or use Supabase CLI:
supabase db push
```

#### Step 3: Create Session Context Utilities

Create `src/lib/agents/context-manager.ts`:

```typescript
import type { Session } from './types'

export class ContextManager {
  /**
   * Extract relevant context from session for agent prompt
   */
  static buildAgentContext(session: Session): string {
    const parts: string[] = []

    // Add conversation summary if available
    if (session.context.summary) {
      parts.push(`Previous conversation summary: ${session.context.summary}`)
    }

    // Add user preferences if set
    if (session.context.certificationLevel) {
      parts.push(`User certification level: ${session.context.certificationLevel}`)
    }

    if (session.context.interests) {
      parts.push(`User interests: ${session.context.interests.join(', ')}`)
    }

    // Add current topic if set
    if (session.context.currentTopic) {
      parts.push(`Current topic: ${session.context.currentTopic}`)
    }

    return parts.length > 0 ? parts.join('\n') : 'New conversation'
  }

  /**
   * Update session context with new information
   */
  static updateContextFromMessage(
    currentContext: Record<string, any>,
    message: string,
    agentResponse: string
  ): Record<string, any> {
    const newContext = { ...currentContext }

    // Extract certification level mentions
    const certLevelMatch = message.match(/\b(open water|OW|advanced open water|AOW|rescue|divemaster)\b/i)
    if (certLevelMatch) {
      newContext.certificationLevel = certLevelMatch[1]
    }

    // Extract location interests
    const locationMatch = message.match(/\b(Malaysia|Thailand|Philippines|Indonesia|Singapore)\b/i)
    if (locationMatch) {
      newContext.interests = newContext.interests || []
      if (!newContext.interests.includes(locationMatch[1])) {
        newContext.interests.push(locationMatch[1])
      }
    }

    // Track message count
    newContext.messageCount = (newContext.messageCount || 0) + 1

    // Update last interaction
    newContext.lastInteraction = new Date().toISOString()

    return newContext
  }

  /**
   * Generate conversation summary for long sessions
   */
  static async generateSummary(messages: Array<{role: string; content: string}>): Promise<string> {
    // Simple summary: take key topics from last 10 messages
    const recentMessages = messages.slice(-10)
    const userMessages = recentMessages
      .filter(m => m.role === 'user')
      .map(m => m.content)
      .join(' | ')

    return `Recent topics: ${userMessages.substring(0, 200)}...`
  }
}
```

## Verification Checklist

- [ ] `src/lib/agents/session-manager.ts` created with SessionManager class
- [ ] `src/lib/agents/context-manager.ts` created with context utilities
- [ ] Database migration `005_session_management.sql` executed
- [ ] `chat_sessions` and `messages` tables exist in Supabase
- [ ] RLS policies applied correctly
- [ ] Indexes created for performance
- [ ] No TypeScript errors

## Troubleshooting

| Issue | Solution |
|-------|----------|
| `chat_sessions` table already exists | Skip CREATE TABLE, only run indexes and RLS policies |
| RLS policy errors | Ensure user is authenticated when testing |
| Foreign key constraint fails | Verify `auth.users` table exists (created by Supabase Auth) |
| Session not persisting | Check `.env.local` has correct Supabase credentials |

## Files Created

- ✅ Created: `src/lib/agents/session-manager.ts` - MCP session management
- ✅ Created: `src/lib/agents/context-manager.ts` - Context utilities
- ✅ Created: `supabase/migrations/005_session_management.sql` - Database schema

## What Comes Next

Next step: **2.3.4-create-specialist-agents.md** - Build Education and Trip Planning agents
