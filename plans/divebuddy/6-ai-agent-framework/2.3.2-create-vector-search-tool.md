# Step 2.3.2: Create Vector Search Tool

**Part of:** PR 2.3 - Google AI Agent Framework Integration  
**Focus:** Build RAG vector search tool for agent context retrieval  
**Estimated Time:** 20 minutes

## Overview

Create a reusable vector search tool that agents can use to retrieve relevant context from the Supabase pgvector knowledge base. This tool will power the RAG (Retrieval-Augmented Generation) pipeline.

## Pre-Step Checklist

- [ ] **Completed:** Step 2.3.1 - Google AI SDK installed
- [ ] **Database:** Supabase pgvector enabled with `diving_documents` table
- [ ] **Embeddings:** Text embedding function available

## Implementation

### Goal

Build a vector search tool that agents can invoke to find relevant diving knowledge or destination information.

### Step-by-Step Instructions

#### Step 1: Create Vector Search Tool

Create `src/lib/agents/tools/vector-search.ts`:

```typescript
import { z } from 'zod'
import { createClient } from '@/lib/supabase/server'
import { getEmbeddingModel } from '@/lib/ai/gemini'
import type { AgentTool } from '../types'

// Tool parameter schema
const VectorSearchParamsSchema = z.object({
  query: z.string().describe('The search query to find relevant information'),
  category: z
    .enum(['education', 'destinations', 'all'])
    .default('all')
    .describe('Category to search within'),
  limit: z
    .number()
    .min(1)
    .max(10)
    .default(5)
    .describe('Maximum number of results to return'),
  threshold: z
    .number()
    .min(0)
    .max(1)
    .default(0.7)
    .describe('Minimum similarity score (0-1)'),
})

export type VectorSearchParams = z.infer<typeof VectorSearchParamsSchema>

// Generate embedding for query
async function embedQuery(query: string): Promise<number[]> {
  const model = getEmbeddingModel()
  const result = await model.embedContent(query)
  return result.embedding.values
}

// Vector search tool implementation
export const vectorSearchTool: AgentTool = {
  name: 'search_knowledge_base',
  description: `Search the diving knowledge base using semantic similarity.
    Use this tool to find accurate information about:
    - Diving certification content (OW, AOW topics)
    - Dive destinations in Malaysia and Asia Pacific
    - Safety procedures and diving techniques
    - Marine life and environmental information`,
  parameters: VectorSearchParamsSchema,
  
  execute: async (params: VectorSearchParams) => {
    try {
      const supabase = createClient()
      
      // Generate embedding for the query
      const queryEmbedding = await embedQuery(params.query)
      
      // Build category filter
      const categoryFilter = params.category !== 'all' 
        ? { category: params.category }
        : {}
      
      // Perform vector similarity search
      const { data, error } = await supabase.rpc('match_documents', {
        query_embedding: queryEmbedding,
        match_threshold: params.threshold,
        match_count: params.limit,
        filter: categoryFilter,
      })
      
      if (error) {
        console.error('Vector search error:', error)
        return {
          success: false,
          error: error.message,
          results: [],
        }
      }
      
      // Format results for agent consumption
      const formattedResults = data.map((doc: any) => ({
        id: doc.id,
        content: doc.content,
        title: doc.metadata?.title || 'Untitled',
        category: doc.metadata?.category || 'unknown',
        similarity: doc.similarity,
        source: doc.metadata?.source || null,
      }))
      
      return {
        success: true,
        results: formattedResults,
        query: params.query,
        count: formattedResults.length,
      }
    } catch (error) {
      console.error('Vector search tool error:', error)
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
        results: [],
      }
    }
  },
}

// Helper: Format search results as text for agent context
export function formatSearchResultsForAgent(results: any[]): string {
  if (results.length === 0) {
    return 'No relevant information found in the knowledge base.'
  }
  
  const formatted = results.map((result, index) => {
    return `
[Result ${index + 1}] ${result.title} (${result.category})
Relevance: ${(result.similarity * 100).toFixed(1)}%
Content: ${result.content}
${result.source ? `Source: ${result.source}` : ''}
---
`.trim()
  }).join('\n\n')
  
  return `Found ${results.length} relevant document(s):\n\n${formatted}`
}
```

#### Step 2: Create Database Function for Vector Search

Create SQL migration `supabase/migrations/004_vector_search_function.sql`:

```sql
-- Create vector search function for pgvector similarity search
CREATE OR REPLACE FUNCTION match_documents(
  query_embedding vector(768),
  match_threshold float DEFAULT 0.7,
  match_count int DEFAULT 5,
  filter jsonb DEFAULT '{}'::jsonb
)
RETURNS TABLE (
  id uuid,
  content text,
  metadata jsonb,
  similarity float
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT
    diving_documents.id,
    diving_documents.content,
    diving_documents.metadata,
    1 - (diving_documents.embedding <=> query_embedding) AS similarity
  FROM diving_documents
  WHERE 
    (filter = '{}'::jsonb OR diving_documents.metadata @> filter)
    AND 1 - (diving_documents.embedding <=> query_embedding) > match_threshold
  ORDER BY diving_documents.embedding <=> query_embedding
  LIMIT match_count;
END;
$$;

-- Create index for faster vector similarity search
CREATE INDEX IF NOT EXISTS diving_documents_embedding_idx 
ON diving_documents 
USING ivfflat (embedding vector_cosine_ops)
WITH (lists = 100);

-- Create GIN index for JSONB metadata filtering
CREATE INDEX IF NOT EXISTS diving_documents_metadata_idx 
ON diving_documents 
USING gin (metadata);
```

Run the migration in Supabase SQL Editor or via CLI:

```bash
# If using Supabase CLI
supabase db push
```

#### Step 3: Create Intent Classifier Tool

Create `src/lib/agents/tools/intent-classifier.ts`:

```typescript
import { z } from 'zod'
import { getChatModel } from '@/lib/ai/gemini'
import type { AgentTool, Intent } from '../types'

const IntentClassifierParamsSchema = z.object({
  message: z.string().describe('User message to classify'),
  conversationHistory: z
    .array(z.string())
    .optional()
    .describe('Previous messages for context'),
})

export const intentClassifierTool: AgentTool = {
  name: 'classify_intent',
  description: `Classify the user's intent to determine which specialist agent should handle the request.
    Returns one of: 'education' (diving learning), 'trip-planning' (destinations), or 'general'.`,
  parameters: IntentClassifierParamsSchema,
  
  execute: async (params: { message: string; conversationHistory?: string[] }) => {
    try {
      const model = getChatModel(0.1) // Low temperature for consistent classification
      
      const prompt = `You are an intent classifier for DiveBuddy, a diving chatbot.

Classify the user's intent into one of these categories:
- "education": Questions about diving certification, techniques, safety, theory (OW/AOW content)
- "trip-planning": Questions about dive destinations, travel planning, where to dive
- "general": Greetings, clarifications, or unclear intent

User message: "${params.message}"

${params.conversationHistory ? `Previous context:\n${params.conversationHistory.join('\n')}` : ''}

Respond with ONLY the category name: education, trip-planning, or general`

      const result = await model.generateContent(prompt)
      const response = result.response.text().trim().toLowerCase()
      
      // Parse and validate intent
      let intent: Intent = 'general'
      if (response.includes('education')) {
        intent = 'education'
      } else if (response.includes('trip') || response.includes('planning')) {
        intent = 'trip-planning'
      }
      
      return {
        success: true,
        intent,
        confidence: response === intent ? 'high' : 'medium',
        rawResponse: response,
      }
    } catch (error) {
      console.error('Intent classification error:', error)
      return {
        success: false,
        intent: 'general',
        confidence: 'low',
        error: error instanceof Error ? error.message : 'Unknown error',
      }
    }
  },
}
```

#### Step 4: Create Tool Registry

Create `src/lib/agents/tools/index.ts`:

```typescript
import { vectorSearchTool } from './vector-search'
import { intentClassifierTool } from './intent-classifier'
import type { AgentTool } from '../types'

// Tool registry for easy access
export const tools = {
  vectorSearch: vectorSearchTool,
  intentClassifier: intentClassifierTool,
} as const

// Export all tools
export { vectorSearchTool, intentClassifierTool }

// Helper: Get tool by name
export function getToolByName(name: string): AgentTool | undefined {
  return Object.values(tools).find(tool => tool.name === name)
}

// Helper: Convert tools to Gemini function declarations
export function toolsToFunctionDeclarations(agentTools: AgentTool[]) {
  return agentTools.map(tool => ({
    name: tool.name,
    description: tool.description,
    parameters: zodToJsonSchema(tool.parameters),
  }))
}

// Convert Zod schema to JSON Schema (Gemini format)
function zodToJsonSchema(schema: any): any {
  // Simple conversion - extend as needed
  const shape = schema._def.shape()
  const properties: any = {}
  const required: string[] = []
  
  for (const [key, value] of Object.entries(shape)) {
    const field = value as any
    properties[key] = {
      type: getJsonType(field),
      description: field.description || '',
    }
    
    if (!field.isOptional()) {
      required.push(key)
    }
    
    // Handle enums
    if (field._def.typeName === 'ZodEnum') {
      properties[key].enum = field._def.values
    }
    
    // Handle numbers with min/max
    if (field._def.typeName === 'ZodNumber') {
      if (field._def.checks) {
        field._def.checks.forEach((check: any) => {
          if (check.kind === 'min') properties[key].minimum = check.value
          if (check.kind === 'max') properties[key].maximum = check.value
        })
      }
    }
  }
  
  return {
    type: 'object',
    properties,
    required,
  }
}

function getJsonType(zodType: any): string {
  const typeName = zodType._def.typeName
  switch (typeName) {
    case 'ZodString': return 'string'
    case 'ZodNumber': return 'number'
    case 'ZodBoolean': return 'boolean'
    case 'ZodArray': return 'array'
    case 'ZodObject': return 'object'
    default: return 'string'
  }
}
```

## Verification Checklist

- [ ] `src/lib/agents/tools/vector-search.ts` created with vector search tool
- [ ] `src/lib/agents/tools/intent-classifier.ts` created with intent classifier
- [ ] `src/lib/agents/tools/index.ts` created with tool registry
- [ ] Database function `match_documents` created in Supabase
- [ ] Vector index created on `diving_documents.embedding`
- [ ] No TypeScript errors
- [ ] Tools export correct schema format

## Troubleshooting

| Issue | Solution |
|-------|----------|
| `diving_documents` table not found | Run PR 2.2 migration to create table |
| Vector search returns no results | Check if embeddings are seeded, lower threshold to 0.5 |
| `match_documents` function error | Verify function created in Supabase SQL Editor |
| Zod validation errors | Ensure Zod version ^3.22.0 installed |

## Files Created

- ✅ Created: `src/lib/agents/tools/vector-search.ts` - RAG vector search tool
- ✅ Created: `src/lib/agents/tools/intent-classifier.ts` - Intent classification tool
- ✅ Created: `src/lib/agents/tools/index.ts` - Tool registry and utilities
- ✅ Created: `supabase/migrations/004_vector_search_function.sql` - Database function

## What Comes Next

Next step: **2.3.3-create-session-manager.md** - Build MCP-based session management
