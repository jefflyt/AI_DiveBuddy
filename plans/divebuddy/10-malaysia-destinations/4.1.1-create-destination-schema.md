# Step 4.1.1: Create Destination Data Schema

**Part of:** PR 4.1 - Malaysia Dive Destination Database  
**Focus:** Design data structure for dive destinations and sites  
**Files to Create:** TypeScript schemas, database migration SQL  
**Estimated Time:** 20 minutes

## Overview

Define comprehensive data structures for storing dive destination information including locations, difficulty ratings, marine life, best seasons, and detailed dive site information.

## Pre-Substep Checklist

- [ ] **Completed:** Phase 3 - Education feature functional
- [ ] **Supabase:** Database access with pgvector enabled
- [ ] **TypeScript:** Project configured with strict typing
- [ ] **Existing tables:** `documents` and `document_chunks` available

## Implementation

### Goal

Create normalized database schema and TypeScript interfaces for dive destinations, dive sites, and related metadata.

### Step-by-Step Instructions

#### Step 1: Create TypeScript Destination Schema

- [ ] Create `lib/types/destination.ts`:

```typescript
export type Region = 'East Malaysia' | 'West Malaysia' | 'Thailand' | 'Philippines' | 'Indonesia' | 'Vietnam'

export type DifficultyLevel = 'beginner' | 'intermediate' | 'advanced' | 'expert'

export type Season = 'year-round' | 'dry' | 'wet' | 'best-mar-oct' | 'best-apr-oct' | 'best-nov-apr'

export interface Coordinates {
  latitude: number
  longitude: number
}

export interface MarineLife {
  category: string // e.g., "Macro", "Pelagic", "Reef"
  species: string[] // e.g., ["Whale Shark", "Manta Ray"]
}

export interface DiveDestination {
  id: string // e.g., "sipadan-malaysia"
  name: string // e.g., "Sipadan Island"
  country: string // e.g., "Malaysia"
  region: Region
  coordinates: Coordinates
  description: string // Long-form description
  shortDescription: string // One-liner for cards
  difficulty: DifficultyLevel
  certification: 'OW' | 'AOW' | 'both'
  
  // Environmental
  waterTemperature: {
    min: number // Celsius
    max: number
  }
  visibility: {
    min: number // meters
    max: number
  }
  depth: {
    min: number // meters
    max: number
  }
  
  // Travel Info
  bestSeason: Season
  accessibility: string // How to get there
  averageCost: {
    currency: string
    perDay: number
  }
  
  // Marine Life
  marineLife: MarineLife[]
  highlights: string[] // e.g., ["Turtle Capital", "Dramatic Drop-offs"]
  
  // Metadata
  imageUrl?: string
  tags: string[]
  createdAt: string
  updatedAt: string
}

export interface DiveSite {
  id: string // e.g., "barracuda-point"
  destinationId: string // Foreign key to DiveDestination
  name: string // e.g., "Barracuda Point"
  description: string
  coordinates: Coordinates
  difficulty: DifficultyLevel
  depth: {
    min: number
    max: number
  }
  current: 'none' | 'mild' | 'moderate' | 'strong'
  highlights: string[]
  marineLife: string[]
}
```

#### Step 2: Create Database Tables

- [ ] Run in Supabase SQL Editor:

```sql
-- Destinations Table
CREATE TABLE IF NOT EXISTS destinations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  slug TEXT UNIQUE NOT NULL, -- URL-friendly ID like "sipadan-malaysia"
  name TEXT NOT NULL,
  country TEXT NOT NULL,
  region TEXT NOT NULL,
  coordinates JSONB NOT NULL, -- {latitude, longitude}
  description TEXT NOT NULL,
  short_description TEXT NOT NULL,
  difficulty TEXT NOT NULL CHECK (difficulty IN ('beginner', 'intermediate', 'advanced', 'expert')),
  certification TEXT NOT NULL CHECK (certification IN ('OW', 'AOW', 'both')),
  
  -- Environmental data
  water_temperature JSONB NOT NULL, -- {min, max}
  visibility JSONB NOT NULL, -- {min, max} in meters
  depth JSONB NOT NULL, -- {min, max} in meters
  
  -- Travel info
  best_season TEXT NOT NULL,
  accessibility TEXT NOT NULL,
  average_cost JSONB, -- {currency, perDay}
  
  -- Content
  marine_life JSONB NOT NULL, -- Array of {category, species[]}
  highlights TEXT[] NOT NULL,
  tags TEXT[] NOT NULL,
  image_url TEXT,
  
  -- Metadata
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Dive Sites Table
CREATE TABLE IF NOT EXISTS dive_sites (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  destination_id UUID NOT NULL REFERENCES destinations(id) ON DELETE CASCADE,
  slug TEXT UNIQUE NOT NULL,
  name TEXT NOT NULL,
  description TEXT NOT NULL,
  coordinates JSONB NOT NULL,
  difficulty TEXT NOT NULL CHECK (difficulty IN ('beginner', 'intermediate', 'advanced', 'expert')),
  depth JSONB NOT NULL, -- {min, max}
  current TEXT NOT NULL CHECK (current IN ('none', 'mild', 'moderate', 'strong')),
  highlights TEXT[] NOT NULL,
  marine_life TEXT[] NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_destinations_region ON destinations(region);
CREATE INDEX idx_destinations_difficulty ON destinations(difficulty);
CREATE INDEX idx_destinations_country ON destinations(country);
CREATE INDEX idx_destinations_slug ON destinations(slug);
CREATE INDEX idx_dive_sites_destination_id ON dive_sites(destination_id);
CREATE INDEX idx_dive_sites_difficulty ON dive_sites(difficulty);

-- Full-text search indexes
CREATE INDEX idx_destinations_name_search ON destinations USING gin(to_tsvector('english', name));
CREATE INDEX idx_destinations_description_search ON destinations USING gin(to_tsvector('english', description));

-- RLS Policies (public read, admin write)
ALTER TABLE destinations ENABLE ROW LEVEL SECURITY;
ALTER TABLE dive_sites ENABLE ROW LEVEL SECURITY;

-- Anyone can read destinations
CREATE POLICY "Public can view destinations"
  ON destinations
  FOR SELECT
  USING (true);

CREATE POLICY "Public can view dive sites"
  ON dive_sites
  FOR SELECT
  USING (true);

-- Only authenticated users can insert (for seeding - can restrict further)
CREATE POLICY "Authenticated users can insert destinations"
  ON destinations
  FOR INSERT
  TO authenticated
  WITH CHECK (true);

CREATE POLICY "Authenticated users can insert dive sites"
  ON dive_sites
  FOR INSERT
  TO authenticated
  WITH CHECK (true);
```

#### Step 3: Create Helper Functions

- [ ] Create destination search function:

```sql
-- Function to search destinations by text
CREATE OR REPLACE FUNCTION search_destinations(
  search_query TEXT,
  region_filter TEXT DEFAULT NULL,
  difficulty_filter TEXT DEFAULT NULL,
  limit_count INTEGER DEFAULT 20
)
RETURNS TABLE (
  id UUID,
  slug TEXT,
  name TEXT,
  country TEXT,
  region TEXT,
  short_description TEXT,
  difficulty TEXT,
  image_url TEXT,
  relevance REAL
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    d.id,
    d.slug,
    d.name,
    d.country,
    d.region,
    d.short_description,
    d.difficulty,
    d.image_url,
    ts_rank(
      to_tsvector('english', d.name || ' ' || d.description || ' ' || array_to_string(d.tags, ' ')),
      plainto_tsquery('english', search_query)
    ) AS relevance
  FROM destinations d
  WHERE
    (region_filter IS NULL OR d.region = region_filter)
    AND (difficulty_filter IS NULL OR d.difficulty = difficulty_filter)
    AND (
      to_tsvector('english', d.name || ' ' || d.description || ' ' || array_to_string(d.tags, ' '))
      @@ plainto_tsquery('english', search_query)
    )
  ORDER BY relevance DESC
  LIMIT limit_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

- [ ] Create destination filter function:

```sql
-- Function to filter destinations by criteria
CREATE OR REPLACE FUNCTION filter_destinations(
  region_filter TEXT DEFAULT NULL,
  difficulty_filter TEXT DEFAULT NULL,
  certification_filter TEXT DEFAULT NULL,
  season_filter TEXT DEFAULT NULL
)
RETURNS SETOF destinations AS $$
BEGIN
  RETURN QUERY
  SELECT *
  FROM destinations d
  WHERE
    (region_filter IS NULL OR d.region = region_filter)
    AND (difficulty_filter IS NULL OR d.difficulty = difficulty_filter)
    AND (certification_filter IS NULL OR d.certification = certification_filter OR d.certification = 'both')
    AND (season_filter IS NULL OR d.best_season LIKE '%' || season_filter || '%')
  ORDER BY d.name;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

#### Step 4: Create Zod Validation Schemas

- [ ] Create `lib/validation/destination.ts`:

```typescript
import { z } from 'zod'

export const CoordinatesSchema = z.object({
  latitude: z.number().min(-90).max(90),
  longitude: z.number().min(-180).max(180),
})

export const MarineLifeSchema = z.object({
  category: z.string(),
  species: z.array(z.string()),
})

export const DestinationSchema = z.object({
  slug: z.string().regex(/^[a-z0-9-]+$/),
  name: z.string().min(1),
  country: z.string(),
  region: z.enum(['East Malaysia', 'West Malaysia', 'Thailand', 'Philippines', 'Indonesia', 'Vietnam']),
  coordinates: CoordinatesSchema,
  description: z.string().min(50),
  shortDescription: z.string().max(200),
  difficulty: z.enum(['beginner', 'intermediate', 'advanced', 'expert']),
  certification: z.enum(['OW', 'AOW', 'both']),
  waterTemperature: z.object({
    min: z.number(),
    max: z.number(),
  }),
  visibility: z.object({
    min: z.number(),
    max: z.number(),
  }),
  depth: z.object({
    min: z.number(),
    max: z.number(),
  }),
  bestSeason: z.string(),
  accessibility: z.string(),
  averageCost: z.object({
    currency: z.string(),
    perDay: z.number(),
  }).optional(),
  marineLife: z.array(MarineLifeSchema),
  highlights: z.array(z.string()),
  tags: z.array(z.string()),
  imageUrl: z.string().url().optional(),
})

export type DestinationInput = z.infer<typeof DestinationSchema>
```

#### Step 5: Install Zod

- [ ] Install validation library:

```bash
npm install zod
```

## Verification Checklist

- [ ] TypeScript types created: `lib/types/destination.ts`
- [ ] Database tables created: `destinations`, `dive_sites`
- [ ] Indexes created for performance
- [ ] RLS policies enabled and configured
- [ ] Helper functions created: `search_destinations`, `filter_destinations`
- [ ] Zod schemas created for validation
- [ ] Zod package installed
- [ ] All SQL runs without errors

## Testing

Test the database schema:

```sql
-- Verify tables exist
SELECT table_name
FROM information_schema.tables
WHERE table_schema = 'public'
  AND table_name IN ('destinations', 'dive_sites');

-- Check indexes
SELECT indexname, tablename
FROM pg_indexes
WHERE tablename IN ('destinations', 'dive_sites');

-- Test search function (will return empty until data seeded)
SELECT * FROM search_destinations('sipadan', 'East Malaysia', NULL, 10);

-- Test filter function
SELECT * FROM filter_destinations('East Malaysia', 'advanced', NULL, NULL);
```

## Troubleshooting

| Issue | Solution |
|-------|----------|
| Table creation fails | Check for existing tables; drop if needed: `DROP TABLE destinations CASCADE;` |
| RLS blocking reads | Verify "Public can view" policies exist; check `USING (true)` clause |
| Function not found | Check function created with correct signature; verify `SECURITY DEFINER` |
| Index creation slow | Normal for large datasets; wait for completion |
| Zod validation errors | Check import paths; ensure types match schema definitions |
| JSONB query errors | Use `->` for object access, `->>` for text; cast as needed |
| Foreign key violation | Ensure destination exists before inserting dive site |

## Files Modified

- [ ] ✅ Created: `lib/types/destination.ts`
- [ ] ✅ Created: `lib/validation/destination.ts`
- [ ] ✅ Created: Database tables via SQL migration
- [ ] ✅ Installed: `zod` package

## What Comes Next

**Next Substep:** 4.1.2 - Write East Malaysia Destination Content

Create detailed destination entries for Sipadan, Mabul, Kapalai, Layang-Layang, and other East Malaysia sites.
